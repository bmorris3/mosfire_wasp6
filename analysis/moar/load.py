# -*- coding: utf-8 -*-
"""
Created on Mon Mar 23 09:50:46 2015

@author: bmmorris
"""

import numpy as np
from matplotlib import pyplot as plt

def spitzer(pathch1, pathch2, plots=False):
    '''
    Load spitzer photometry in channels 1 and 2, which have already been
    reduced with PLD by Sarah. 
    
    Parameters
    ----------
    pathch1 : str
        Path to the channel 1 ascii file. Format = JD-2450000, Flux, Error
        
    pathch2 : str
        Path to the channel 2 ascii file. Format = JD-2450000, Flux, Error
        
    Returns
    -------
    ch1 : dict
        Dictionary containing three keywords: 't', 'f', 'e' for the JD
        flux and fiducial uncertainties, respectively.
        
    ch2 : dict
        Dictionary containing three keywords: 't', 'f', 'e' for the JD
        flux and fiducial uncertainties, respectively.
    '''
    # Generated by spitzer/thirdPLDset.ipynb
    rawch1 = np.genfromtxt(pathch1)
    rawch2 = np.genfromtxt(pathch2)
    
    ch1 = {}
    ch2 = {}
    for rawdata, output in zip([rawch1, rawch2], [ch1, ch2]):
        for i, key, offset in zip(range(3), ['t', 'f', 'e'], 
                                  [2450000.0, 0.0, 0.0]):
            output[key] = rawdata[:,i] + offset
    
    for ch in [ch1, ch2]:
        ch['e'] = np.zeros_like(ch['f']) + np.std(
                    ch['f'][int(0.66*len(ch['f'])):])

    if plots:
        fig, ax = plt.subplots(1,2,figsize=(16,10), sharey='row', sharex='col')
        for i, ch in enumerate([ch2, ch1]):
            ax[i].errorbar(ch['t'], ch['f'], yerr=ch['e'], fmt='.', color='k', ecolor='gray')
        
        
        ax[0].set_ylabel('Relative Flux')
        plt.show()

  
    return ch1, ch2
    
def mosfire(photproductspath, plots=False):
    '''
    Load MOSFIRE photometry
    
    Parameters
    ----------
    photproductspath : str
        Path to the saved photometry outputs.
    
    Returns
    -------
    (fluxes, errors, times, airmass, wavelengthbincenters, 
            exposuredurs, wavelengthbounds) : tuple
    '''    
    fluxes = np.load(photproductspath+'/fluxes.npy')
    errors = np.load(photproductspath+'/errors.npy')
    times = np.load(photproductspath+'/times.npy')
    airmass = np.load(photproductspath+'/airmass.npy')
    wavelengthbincenters = np.load(photproductspath+
                                   '/wavelengthbincenters.npy')
    exposuredurs = np.load(photproductspath+'/exposuredurs.npy')
    wavelengthbounds = np.load(photproductspath+'/wavelengthbounds.npy')
    
    if plots:
        lightcurve = fluxes[:, 1, :, 0]/fluxes[:, 0, :, 0]
        lightcurve_errors = lightcurve*np.sqrt((errors[:, 1, :, 0]/
                            fluxes[:, 1, :, 0])**2 + (errors[:, 0, :, 0]/
                            fluxes[:, 0, :, 0])**2)
        fig, ax = plt.subplots(1, figsize=(14,14))
        mintimeint = int(np.min(times))
        cmap = plt.cm.autumn
        for eachbin in range(len(lightcurve[0,:])):
            ax.errorbar(times - mintimeint, lightcurve[:,eachbin] + eachbin*0.02,
                        yerr=lightcurve_errors[:,eachbin], fmt='.', 
                        color=cmap(1 - eachbin / float(len(lightcurve[0,:]))), 
                        ecolor='gray')
            ax.set_xlabel('JD - %d' % mintimeint)
            ax.set_ylabel('Relative Flux')
            ax.grid()
        plt.show()    
    
    return (fluxes, errors, times, airmass, wavelengthbincenters, 
            exposuredurs, wavelengthbounds)



